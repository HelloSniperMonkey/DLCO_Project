//Soumyajyoti Mohnata
//Roll No. : 2301AI23
// emualtor for binary generated by assembler
#include <iostream>
#include <vector>
#include <cstdint>
#include <fstream>
#include <iomanip>
using namespace std;

vector<int32_t> instructions(1e7, 0);
// Registers
int32_t A = 0;  // Accumulator
int32_t B = 0;  // Secondary accumulator
int32_t PC = 0; // Program counter
int32_t SP = 0; // Stack pointer
bool running = true;

bool execute(int32_t instruction)
{
    int32_t opcode = instruction & 0xFF;    // Lower 8 bits
    int32_t operand = instruction >> 8; // Upper 24 bits

    switch (opcode)
    {
    case 0: // ldc
        B = A;
        A = operand;
        break;

    case 1: // adc
        A += operand;
        break;

    case 2: // ldl
        B = A;
        A = instructions[SP + operand];
        break;

    case 3: // stl
        instructions[SP + operand] = A;
        A = B;
        break;

    case 4: // ldnl
        A = instructions[A + operand];
        break;

    case 5: // stnl
        instructions[A + operand] = B;
        break;

    case 6: // add
        A = B + A;
        break;

    case 7: // sub
        A = B - A;
        break;

    case 8: // shl
        A = B << A;
        break;

    case 9: // shr
        A = B >> A;
        break;

    case 10: // adj
        SP += operand;
        break;

    case 11: // a2sp
        SP = A;
        A = B;
        break;

    case 12: // sp2a
        B = A;
        A = SP;
        break;

    case 13: // call
        B = A;
        A = PC;
        PC += operand;
        break;

    case 14: // return
        PC = A;
        A = B;
        break;

    case 15: // brz
        if (A == 0)
            PC += operand;
        break;

    case 16: // brlz
        if (A < 0)
            PC += operand;
        break;

    case 17: // br
        PC += operand;
        break;

    case 18: // HALT
        running = false;
        break;

    case 20: // data
        instructions[PC] = operand;
        break;

    default:
        cerr << "Invalid opcode: " << opcode << endl;
        return false;
    }
    return true;
}

int main(int argc, char *argv[])
{
    if (argc != 3)
    {
        cerr << "Usage: " << argv[0] << " <binary_file> <trace_file_name>" << endl;
        return 1;
    }
    ifstream file(argv[1], ios::binary);
    if (!file)
    {
        cerr << "Could not open file: " << argv[1] << endl;
        return false;
    }
    PC = 0;
    while (file.read(reinterpret_cast<char *>(&instructions[PC]), sizeof(int32_t)))
    {
        PC++;
    }
    int t=0;
    ofstream trace(argv[2]);
    while(t<PC){
            if(t%4==0){
                cout<<endl;
                trace<<endl;
                cout<<hex<<setw(8) << setfill('0')<<t<<"| ";
                trace<<hex<<setw(8) << setfill('0')<<t<<"| ";
            }
            cout << hex << setw(8) << setfill('0') << instructions[t] << " ";
            trace << hex << setw(8) << setfill('0') << instructions[t] << " ";
        t++;
    } 
    cout<<endl;
    int lines = PC;
    PC = 0;
    int i=0;
    
    while (PC <= lines)
    {   
        i++;
        trace << "A: " << A << " B: " << B << " PC: " << PC << " SP: " << SP << endl;
        int32_t instruction = instructions[PC];
        PC++;
        if (!execute(instruction))
        {
            cerr << "Error at line: " << PC << endl;
            return 1;
        }
        if (!running)
        {
            break;
        }
    }
    cout <<"----------------------------------------------------"<<endl;
    cout<<endl<<i<< " instructions executed"<<endl;
    cout<<"Final Registers:"<<endl;
    cout << "A: " << A << " B: " << B << " PC: " << PC << " SP: " << SP << endl;
    cout << "------------------------MEMORY---------------------" << endl;

    trace <<"----------------------------------------"<<endl;
    trace <<i<< " instructions executed"<<endl;
    trace <<"Final Registers:"<<endl;
    trace << "A: " << A << " B: " << B << " PC: " << PC << " SP: " << SP << endl;
    trace << "------------------------MEMORY---------------------" << endl;
    t = 0;
    while(t<PC){
            if(t%4==0){
                cout<<endl;
                trace<<endl;
                cout<<hex<<setw(8) << setfill('0')<<t<<"| ";
                trace<<hex<<setw(8) << setfill('0')<<t<<"| ";
            }
            cout << hex << setw(8) << setfill('0') << instructions[t] << " ";
            trace << hex << setw(8) << setfill('0') << instructions[t] << " ";
        t++;
    }
    return 0;
}